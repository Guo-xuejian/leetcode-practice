# LCP 29. 乐团站位
# 某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。

# 为保证声乐混合效果，成员站位规则为：自 grid 左上角开始顺时针螺旋形向内循环以 1，2，...，9 循环重复排列。例如当 num = 5 时，站位如图所示

# image.png

# 请返回位于场地坐标 [Xpos,Ypos] 的成员所持乐器编号。

# 示例 1：

# 输入：num = 3, Xpos = 0, Ypos = 2

# 输出：3

# 解释：
# image.png

# 示例 2：

# 输入：num = 4, Xpos = 1, Ypos = 2

# 输出：5

# 解释：
# image.png

# 提示：

# 1 <= num <= 10^9
# 0 <= Xpos, Ypos < num


class Solution:
    def orchestraLayout(self, num: int, xPos: int, yPos: int) -> int:
        '''找规律，数学题'''
        # 为了写的方便
        x, y = xPos, yPos
        # 计算处在第几层
        m = min(x, y, num - x - 1, num - y - 1)
        # 计算前 m-1 层一共有多少个数字,总结一下规律就是一个等差数列
        total = 4 * m * (num-m)
        # 判断出第 m 层第一个数字是什么
        m_first = 9 if (total+1) % 9 == 0 else (total + 1) % 9
        # 计算出第 m 层有多少个数字
        m_num = 4 * (num-1-2*m)
        # 判断当前的数字位于第 m 层的第几个

        # 分两种情况，一种是 y 的坐标大于等于 x 的坐标，一种是 y 的坐标小于 x 的坐标
        # 如果是第一种情况，直接正着数若干个，如果是第二种情况，倒着数若干个
        # 接下来说一下怎么求这个若干个，举个简单例子，
        """
            如果我们就位于第一层，按照索引说是第 0 层，那么顺时针的时候观察索引的变化，
            是不是用横坐标加纵坐标加 1 就是第几个数，其实是减去了层数，也就是 x - 0 + y - 0 + 1
            那么如果是在第 m 层不就是 x - m + y - m + 1

            当然如果是第二种情况这时候正着的计算方法就不对了，我们可以使用这一层的数字总数减去 x - m + y - m 加 1
            因为如果 2 - 1 等于 1, 2 其实是位于第二个数
        """
        # 接着看代码
        if x <= y:  # 正着数
            count = x - m + y - m + 1
        else:  # 倒着数
            count = m_num - (x - m + y - m) + 1

        # 得到了第一个数，得到了第几个，接下来简单多了吧
        res = 9 if (m_first + count -
                    1) % 9 == 0 else (m_first + count - 1) % 9

        return res
